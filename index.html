<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
    /************************/
    //    ПЕРЕМЕННЫЕ 
    /************************/
        // Правикльно
        let userName = "ok";
        let myClass8 = 'ok';
        let $name = 'норм';
        let _name = 'для классов'

        // Не рекомендуется
        let user_name = "не рекомендуется"; 
        let UserName = "не рекомендуется";
        // let 8Class = "ошибка";
        // let my-Var = 'ошибка';
        // let const = "ошибка"

    /************************/
    //    Операторы арифметические 
    /************************/
        /* оператор - это внетренняя функция в js. Вызывается в зависимости от типа оператора
            ВИДЫ ОПЕРАТОРОВ:
            Оператор присваивания       =  += (a = a  + число) -= (a = a  - число) *= (a = a * число) /= (a = a / число)  ++ (a + 1)  -- (a - 1)
                    сравнение           ==  ===  > >= < <= 
                    арифметический      + - * /         (2**3  тоже самое что и 2 * 2 * 2)
                    битовые логические
                    логический
                    Сроковые            + (конкатенация)
                    Тернарный 
                    Запятая
                    Унарные
                    Отношения
        */

    /************************/
    //    Порядок операторов
    /************************/
    // Сначала выполняются операции с более высоким приоритетом!!!!
    /*
     > (10) у больше приоритет 10
     <= (10)
     > (10)
     >= (10)
     - (12) у вычитания приоритет 12
     + (12) у сложения приоритет 12
     * (13) умножение приоритет 13
     / (13) деление приоритет 13
     ** (14) возведение в степень приоритет 14 
     () (19)
     
     Пример: c = b = 10 + 5; получим с = 150; b = 150;
     https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
    */


    /************************/
    //    ТИПЫ ДАННЫХ
    /************************/

    //  Все данные делятся на 2 типа: ОБЪЕКТЫ И ПРИМИТИВЫ!
    // console.log(typeof a) - узнать тип переменной
    /** ПРИМИТИВЫ
     числа 
     строки 
     true false
     undefined  (не заданное значение, ТИП НЕ ОПРЕДЕЛЕН!)
     null (явно заданное пустое значение)
     Symbol('Тест') (уникальное неизменяемое значение)
     bigInt(99...) работа с большими числами

    */


    /************************/
    //    Преобразование типов
    /************************/
    let ps = "5";
    console.log(ps + 5)  // 55  (строка + число = строка)
    console.log(ps - 5) // 0 (не явное переобразование из строки в числj)
    console.log(ps / 5) // 1 (не явное переобразование из строки в числj)
    console.log(+ps + 5) // 10 (+ в начале строки делает из строки число)
    console.log(Number(ps) + 5) // 10 (явное переобразование из строки в число)
    console.log(String(ps) + 5) // 55 (явное переобразование из строки в число)
    console.log(Boolean("")) // false
    console.log(Boolean("a")) // true

    /************************/
    //   False из других типов
    /************************/
    console.log(Boolean(0))         // false
    console.log(Boolean(''))        // false
    console.log(Boolean(undefined)) // false
    console.log(Boolean(null))      // false
    console.log(Boolean(NaN))       // false


    /************************/
    //   SWITCH - удобен если есть много вариантов условий. Проверяется путем строгого сравнения 
    /************************/
    const role = "manager"
    // 1 вариант - обычный. Если строго совпало role === "manager"
        switch(role) {
            case 'manager':                     // if (role === "manager")
                console.log("Менеджер")
                break;                          // если условие совпадает, то после break НИЧЕГО НЕ ВЫПОЛНЯЕТСЯ!!
            case 5:                             
                console.log("Цифра 5")
                break;
            default:                            // значение по дефолту, если ни один case не совпал  (можно не указывать)
                console.log("мы тебя не знаем")
        }
    // Если есть 2 совпадения и больше
        switch(role) {
        case 'manager': 
        case 'administrator':
        case 'security': 
            console.log("1 из условий выше совпало: администратор управляющий и охранник")
            break;
        default:    // значение по дефолту, если ни один case не совпал  (можно не указывать)
            console.log("мы тебя не знаем")
         }
    // 3 Пример использования больше или меньше
        const a = 5;
        
        switch(true) {
            case a > 1 :                     
                console.log(" a больше 1")
                break;
            case a < 1:                             
                console.log(" a больше 2")
                break;
        default:    // 
            console.log("НОЛЬ")
         }

    /************************/
    //   ТЕРНАРНЫЙ (условный) ОПЕРАТОР 
    /************************/
    // пример 1 - стандартный.  короткая запись, замена обычному if else
    10 > 0 ? console.log('больше') : console.log('Не больше');
    
    // пример 2 - если нужно вывести несколько действий, то нужно обернуть их в () скобки
    10 > 0 ? (
        console.log('1 действие'),
        console.log('2 действие'),
        console.log('3 действие')
        ) : (
            console.log('иначе')
        );

    /************************/
    //   ФУНКЦИИ 
    /************************/
    // обычная функция от функции через переменную отличаются лишь вспылтием. Т.е. функцию через переменную нельзя вызвать до объявления. 

    // обычная функция - 1. у нее есть имя (идентификатор) 2. её вызов может быть выше неё (вспылтие) 3. Есть this (контекст)
    function powerOfTwo (num) {
        return num * num; // после return ниже код не выполняется! Так же используется вместо else
    }
    console.log(powerOfTwo(2))


    // анонимная функция - записывается как ссылка в переменную. 1. нет имени 2. нет вспылтия 3. есть this
    const myFunc = function  (num) {
        return num * num;
    }
    console.log(myFunc(2))


    // стрелочная функция - более короткий вариант записи. Не нужно писать return. Удобна для простых функций. Не имеет своего this. Нет всплытия..
    const poft = (num) => num * num; // 1 аргумент

    const pof2 = (num, qwe) => { console.log(qwe); return num * num }; // 2 аргумент. записываем уде в фигурные скобки и добавляем return


    /************************/
    //   МАССИВЫ -  упорядоченная коллекция данных
    /************************/
    const roles = ['admin', 'user', 'superuser']; //  массив
    console.log(roles)     //   0 : "admin" 1 : "user" 2 : "superuser" length : 3 
    console.log(roles[0])   // admin                        (самое первое значение)
    console.log(roles.length)   // 3                        (длина массива (кол-во элементов в массиве) )
    console.log(roles[roles.length - 1])   // superuser     (последний элемент)
    // новые синтаксис
    console.log(roles.at(0)); // тоже самое что и console.log(roles[0])
    console.log(roles.at(-1)); // тоже самое что иc onsole.log(roles[roles.length - 1])
    //  математика в массиве
    const usrAge = [2023 - 1991, 2 + 2]; //   [32, 4]

    // работа с массивами
    roles[2] = 'Новое имя' // изменить 3 значение
    roles[3] = 'Добавить' // добавить к массиву 4 элемент (редко используется)
    roles.push('Никита') //  добавить в КОНЕЦ. возвращает длину массива
    roles.unshift('Вася') //  добавить в НАЧАЛО 
    roles.pop() //  удаляет последний элемент. возвращает удаленный элемент
    roles.shift() //  удаляет первый элемент. возвращает удаленный элемент
    roles.splice(2,1) //  вырежит 1 элемент 3й по порядку (т.е. "2,1" - 2 начало, 1 кол-во). изменяет масив!
    roles.slice(2) //  вернет все элементы начиная с 3. не изменяет массив. 
    roles.slice(0,2) //  вернет 2 элемент с 0 по 1 не включая 2
    roles.concat(usrAge) // объеденгить массивы
    roles.reverse() // переворачивает в обратном направлени. Модифицирует массив!

    // поиск\проверка элемента
    const elIndex = roles.indexOf('user') // 1  вернет первый найденый индекс нужного элемента 
    const elIndexx = roles.includes('user') // вернет true или false в зависимости есть ли элемент 
    console.log(elIndexx)

    // разбить (преобразовать) строку на массив
    const ссылка = 'auth/user/login';
    const результат = ссылка.split('/') // разбиваем и указываем разделитель
    console.log(результат) // получим  ['auth', 'user', 'login']

    // из массива в строку
    const строка = roles.join(', ');
    console.log(строка) // получим   admin, user, Новое имя, Добавить

    // Деструктуризация массива - берем структуру массива и разбиваем на отдельные элементы
    const userData = ['Антон', 18, "Полтава"];
    // БЫЛО -  много кода, 3 строки
    const userNames = userData[0];
    const userAge = userData[1];
    const userCity = userData[2];
    console.log(userNames + userAge + userCity)
    // СТАЛО - мало кода, 1 строка
    const [userNams, userAg, userCit] = userData;
    // const [userNams, _, userCit] = userData;  // если нужно только 2 переменные, то лишнюю можно закрасить символом _
    // Rest оператор
    // const [userNams, ...others] = userData;  // записываем 1 переменную, остальные элементы отправляются в ...others
    console.log(userNams + userAg + userCit)


    /************************/
    //   ЦИКЛЫ
    /************************/
    let массив = ['Задача1', 'Задача2', 'Задача3','Задача4']

    // стандартный обход массива. простая переборка  массива если НЕ НУЖЕН ИНДЕКС. обход идёт по значениям
    for (let element of массив) {
        console.log(element)
    }
    //  если нужен индес. обход идет по индексам
    for (let index in массив) {
        console.log(массив[index]) // вывести индекст
        console.log(index) // вывести значение
    }

    //  ЦИКЛ for используется для обычной итерации, т.е. увеличиваем на нужное значение (i++ или i+2...)
    //       начало;        условие;      шаг
    for( let i = 0; i < массив.length ; i++ ){
        console.log(массив[i])
        /*получим:  задача 1  задача 2 */

        /*  Доп условия Continue Breack
        if(массив[i] === 'Задача2') {
            continue; если нужно пропустить элемент то можно указать continue
            break; останавливает цикл
        }
        */
    }

    //  while - если нужно нестандартно проверить концец кикла то лучше использовать этот цикл
    let arrrr = [1,2,3,4]
    let abc = 0;
    while (arrrr[abc] <= 5 && abc < arrrr.length) { // т.е. если длина массива < 5 
        console.log(arrrr[abc]);
        abc++;
    }

    // do while - проверка сработает после проверки условия
    let j = 0;
    do {
        console.log(j)
        j++
    } while (j < 0)


    /************************/
    // Функции высшего порядка и функции первого класса
    /************************/

    // функция первого класса - это функция которую мы можешь использоваь как переменную, т.е. могут быть переданы в другие ф-ции и их можно вернуть из функций
    const w =  (b) => b++; // передаем аргумент b и потом увеличиваем на 1

    // функции высшего порядка - это те функции, которые либо принимают другие функции либо возвращают
    function g(w) { // функция g принимает! функцию w как аргумент
        return w; // возращаеn! функцию
    }

    // Callback - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия

    function add(a,b) { // простая функция
        return a + b
    }
    function culc(a,b, fn) { // функция высшего порядка, которая принимает в параметре fn функцию add
        return fn(a,b);
    }
    let res = culc(3,5, add) // результат


    
    // возврат одной функции из другой DEMO
    function power(pow) { // функция ничего не делает, просто возвращает другую функицю
        return function (num) { // эта функция возвращает число возведенное в степень
            return num**pow;
        }
    }
    //  короткая запись через стрелочную функцию   const power = pow => num => num**pow;
    const powerOfTwo = power(2); // результат выполнения функции power. т.е. создаем новую функцию с сохранением предыдущего контекста
    console.log(powerOfTwo(5))
    // console.log(power(2)(5))  // короткая запись. вызываем фунцию power(2) c аргументом 5

    /************************/
    // ИТЕРАЦИИ В МАССИВАХ
    /************************/

    // forEach - обходм массива . Есть проблемы с асинхронным кодом. Нельзя прикрат. цикл. Удобен для простого вывода\итерирования.
    const score = ["a","b","c","d"];                 // a 0
    score.forEach((el, i) => {      //получим        // b 1
        console.log(el, i)                           // c 2
    })                                               // d 3

    // map - позволяет взять исходный массив и как-то его преобразовать. Умножим каждый элемент массива на 60
    const cost = [5,6,7,8];
    const transInRub = cost.map((transaction, i) => {
        return transaction * 60
    });   // получим [300, 360, 420, 480]

    // filter  - Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
    //Пример: вернет все положительные числа из массива
    const operation = [100, -20, 7, -1, 50]
    const posotovOperat = operation.filter((op) => {
        return op > 0  
    }) // получим  [100, 7, 50]

    // reduce - сужаем массив до одного значения. Например, посчитаем финальную сумму (балланс)
    const bal = [100, -20, 7, -1, 50]
    const finalBalance = bal.reduce((acc, op) => {
        return acc += op; // получим 136 
    }, 0) // начальная величина т.е. 0

        // find - найти что-то в массиве
        // пример: найти перый элемент кот. больше 5
        const numbrs = [2,3,7,9]

        let ress;
        ress = numbrs.find(el => el >5); // получим 7
        // ress = numbrs.findIndex(el => el >5); // findIndex вернет индекс найденнго элемента.  получим 2
    
        //  some - проверяет массив на наличие элемента
        console.log(numbrs.some(el => el === 2))  // вернет true (2 есть в массиве)

        // flat - возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень
        const arr1 = [1, 2, [3, 4]];
        arr1.flat(); // (?) тут указываем значение глубины массива. по умолчанию 1
        // [1, 2, 3, 4]

        //  sort - сортировка  (мутируется существующий массив). ПО умолчанию работает как со строками
        // пример: отсортируем массив по алфавиту
        const arr3 = ['b','c', 'm', 'a'];
        arr3.sort(); // получим  ['a', 'b', 'c', 'm']

        // пример: отсортируем массив по порядку
        const arr4 = [5,-2, 1, 9];
        arr4.sort((a, b) => a - b); // получим  [-2, 1, 5, 9]


    /************************/
    // СТРОКИ
    /************************/

    const  userNm = 'Вася Пупкин';
    
    // ПОЛУЧАЕМ нужную букву из строки
    console.log(userNm[0])  //// получаем первую букву > В
    console.log(userNm.charAt(1)) // тоже самое только через метод charAt. получаем > В
    userNm = 'Вася Пупкин';[1] // самый простой вариант

    // Длина строки
    userNm.length // 11

    // Поиск по строки
    userNm.indexOf('П') // 5  (вернет первое вхождение найденой буквы)
    userNm.lastIndexOf('п') // 7  (вернет последнее вхождение найденой буквы)
    userNm.includes('п') // true
    userNm.slice('5') // вырежит 5 эдементов вернет > "Пупкин" 

    // Преобразование срок
    userNm.toLowerCase() // перевести все буквы в нижний регист 'вася пупкин' 
    userNm.toUpperCase() // перевести все буквы в верхний регист 'ВАСЯ ПУПКИН'
    userNm.replace('В', 'К') // меняем первую найденную букву В на К >  'Кася Пупкин'  (не подифиц. исход. объект)
    userNm.replaceAll('В', 'К') // заменит все найденные буквы В на К  (не везде поддерживается) Лучше делать так - userNm.replace(/В/, 'К')

    // Разбить строку на массив  
    userNm.split(' ')  // ['Вася', 'Пупкин']
    // Из массива в строку
    arr3.join(' ') // было ['a', 'b', 'c', 'm']   стало   'a b c m'

    // добавить символы в начало строки (указываем общее кол-во и нужный символ)
    userNm.padStart(20, '*') // '*********Вася Пупкин'  
    userNm.padEnd(12, '*') // 'Вася Пупкин****'
    userNm.repeat(2)// 'Вася ПупкинВася Пупкин'  повторить 2 раза


    /************************/
    // ОБЪЕКТЫ - коллекция свойств состоящая из пар ключ-значение.
    /************************/
    // пример объекта
    const user = {
        name: 'Вася',
        surname: 'Пупкин',
        age: 24,
        1: 2,
        skills: [ // массив в обхект
            'скорость',
            'выносливость',
        ]
    }

    // обращени к элементам
    console.log(user) // обращение ко всему объекту
    console.log(user.skills[0]) // "скорость"   - обращение к элементу массива

    console.log(user.skills) // не  доступно для расчетных свойств . Чаще всего используется
    console.log(user['skills']) // доступно для расчетных свойств. Например user['sur' + 'name'] где 'name' может быть переменная

    user.age = 30 // модифицируем объект (изменяем значение)
    user.city = 'Lviv' // добавляем новое значение

    // ПРАКТИКА!  Сортировка массива объектов по возрасту
    const users = [
        {name: 'Вася', age: 30},
        {name: 'Катя', age: 18},
        {name: 'Аня', age: 40},
        {name: 'Петя', age: 25},
    ]
    users.sort((a,b) => {
        return a.age - b.age
    })
    /* получаем:
        {name: 'Катя', age: 18}
        {name: 'Петя', age: 25}
        {name: 'Вася', age: 30}
        {name: 'Аня', age: 40}
    */


    // ПРАКТИКА!  преобразовать пользователей до вида {fullName: "Вася Пупкин", skillNum: 2}
    const users2 = [
        {
            name: 'Вася', 
            surname: 'Пупкин',
            age: 30,
            skills: ["Разработка", "DevOps"]
        },
        {
            name: 'Катя', 
            surname: 'Белова',
            age: 18,
            skills: ["дизайн"]
            } ,
    ]
    const result = users2.map(user => {
        return {
            fullName: `${user.name} ${user.surname}`,
            skillNum: user.skills.length
        };
    })
    /* получаем
        {fullName: 'Вася Пупкин', skillNum: 2}
        {fullName: 'Катя Белова', skillNum: 1}
    */




    
    // МЕТОДЫ объектов
    </script>

        

</body>
</html>