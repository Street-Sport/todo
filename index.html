<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
    /************************/
    //    ПЕРЕМЕННЫЕ 
    /************************/
        // Правикльно
        let userName = "ok";
        let myClass8 = 'ok';
        let $name = 'норм';
        let _name = 'для классов'

        // Не рекомендуется
        let user_name = "не рекомендуется"; 
        let UserName = "не рекомендуется";
        // let 8Class = "ошибка";
        // let my-Var = 'ошибка';
        // let const = "ошибка"

    /************************/
    //    Операторы арифметические 
    /************************/
        /* оператор - это внетренняя функция в js. Вызывается в зависимости от типа оператора
            ВИДЫ ОПЕРАТОРОВ:
            Оператор присваивания       =  += (a = a  + число) -= (a = a  - число) *= (a = a * число) /= (a = a / число)  ++ (a + 1)  -- (a - 1)
                    сравнение           ==  ===  > >= < <= 
                    арифметический      + - * /         (2**3  тоже самое что и 2 * 2 * 2)
                    битовые логические
                    логический
                    Сроковые            + (конкатенация)
                    Тернарный 
                    Запятая
                    Унарные
                    Отношения
        */

    /************************/
    //    Порядок операторов
    /************************/
    // Сначала выполняются операции с более высоким приоритетом!!!!
    /*
     > (10) у больше приоритет 10
     <= (10)
     > (10)
     >= (10)
     - (12) у вычитания приоритет 12
     + (12) у сложения приоритет 12
     * (13) умножение приоритет 13
     / (13) деление приоритет 13
     ** (14) возведение в степень приоритет 14 
     () (19)
     
     Пример: c = b = 10 + 5; получим с = 150; b = 150;
     https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
    */


    /************************/
    //    ТИПЫ ДАННЫХ
    /************************/

    //  Все данные делятся на 2 типа: ОБЪЕКТЫ И ПРИМИТИВЫ!
    // console.log(typeof a) - узнать тип переменной
    /** ПРИМИТИВЫ
     числа 
     строки 
     true false
     undefined  (не заданное значение, ТИП НЕ ОПРЕДЕЛЕН!)
     null (явно заданное пустое значение)
     Symbol('Тест') (уникальное неизменяемое значение)
     bigInt(99...) работа с большими числами

    */


    /************************/
    //    Преобразование типов
    /************************/
    let ps = "5";
    console.log(ps + 5)  // 55  (строка + число = строка)
    console.log(ps - 5) // 0 (не явное переобразование из строки в числj)
    console.log(ps / 5) // 1 (не явное переобразование из строки в числj)
    console.log(+ps + 5) // 10 (+ в начале строки делает из строки число)
    console.log(Number(ps) + 5) // 10 (явное переобразование из строки в число)
    console.log(String(ps) + 5) // 55 (явное переобразование из строки в число)
    console.log(Boolean("")) // false
    console.log(Boolean("a")) // true

    /************************/
    //   False из других типов
    /************************/
    console.log(Boolean(0))         // false
    console.log(Boolean(''))        // false
    console.log(Boolean(undefined)) // false
    console.log(Boolean(null))      // false
    console.log(Boolean(NaN))       // false


    /************************/
    //   SWITCH - удобен если есть много вариантов условий. Проверяется путем строгого сравнения 
    /************************/
    const role = "manager"
    // 1 вариант - обычный. Если строго совпало role === "manager"
        switch(role) {
            case 'manager':                     // if (role === "manager")
                console.log("Менеджер")
                break;                          // если условие совпадает, то после break НИЧЕГО НЕ ВЫПОЛНЯЕТСЯ!!
            case 5:                             
                console.log("Цифра 5")
                break;
            default:                            // значение по дефолту, если ни один case не совпал  (можно не указывать)
                console.log("мы тебя не знаем")
        }
    // Если есть 2 совпадения и больше
        switch(role) {
        case 'manager': 
        case 'administrator':
        case 'security': 
            console.log("1 из условий выше совпало: администратор управляющий и охранник")
            break;
        default:    // значение по дефолту, если ни один case не совпал  (можно не указывать)
            console.log("мы тебя не знаем")
         }
    // 3 Пример использования больше или меньше
        const a = 5;
        
        switch(true) {
            case a > 1 :                     
                console.log(" a больше 1")
                break;
            case a < 1:                             
                console.log(" a больше 2")
                break;
        default:    // 
            console.log("НОЛЬ")
         }

    /************************/
    //   ТЕРНАРНЫЙ (условный) ОПЕРАТОР 
    /************************/
    // пример 1 - стандартный.  короткая запись, замена обычному if else
    10 > 0 ? console.log('больше') : console.log('Не больше');
    
    // пример 2 - если нужно вывести несколько действий, то нужно обернуть их в () скобки
    10 > 0 ? (
        console.log('1 действие'),
        console.log('2 действие'),
        console.log('3 действие')
        ) : (
            console.log('иначе')
        );

    /************************/
    //   ФУНКЦИИ 
    /************************/
    // обычная функция от функции через переменную отличаются лишь вспылтием. Т.е. функцию через переменную нельзя вызвать до объявления. 

    // обычная функция - 1. у нее есть имя (идентификатор) 2. её вызов может быть выше неё (вспылтие) 3. Есть this (контекст)
    function powerOfTwo (num) {
        return num * num; // после return ниже код не выполняется! Так же используется вместо else
    }
    console.log(powerOfTwo(2))


    // анонимная функция - записывается как ссылка в переменную. 1. нет имени 2. нет вспылтия 3. есть this
    const myFunc = function  (num) {
        return num * num;
    }
    console.log(myFunc(2))


    // стрелочная функция - более короткий вариант записи. Не нужно писать return. Удобна для простых функций. Не имеет своего this. Нет всплытия..
    const poft = (num) => num * num; // 1 аргумент

    const pof2 = (num, qwe) => { console.log(qwe); return num * num }; // 2 аргумент. записываем уде в фигурные скобки и добавляем return


    /************************/
    //   МАССИВЫ -  упорядоченная коллекция данных
    /************************/
    const roles = ['admin', 'user', 'superuser']; //  массив
    console.log(roles)     //   0 : "admin" 1 : "user" 2 : "superuser" length : 3 
    console.log(roles[0])   // admin                        (самое первое значение)
    console.log(roles.length)   // 3                        (длина массива (кол-во элементов в массиве) )
    console.log(roles[roles.length - 1])   // superuser     (последний элемент)
    // новые синтаксис
    console.log(roles.at(0)); // тоже самое что и console.log(roles[0])
    console.log(roles.at(-1)); // тоже самое что иc onsole.log(roles[roles.length - 1])
    //  математика в массиве
    const usrAge = [2023 - 1991, 2 + 2]; //   [32, 4]

    // работа с массивами
    roles[2] = 'Новое имя' // изменить 3 значение
    roles[3] = 'Добавить' // добавить к массиву 4 элемент (редко используется)
    roles.push('Никита') //  добавить в КОНЕЦ. возвращает длину массива
    roles.unshift('Вася') //  добавить в НАЧАЛО 
    roles.pop() //  удаляет последний элемент. возвращает удаленный элемент
    roles.shift() //  удаляет первый элемент. возвращает удаленный элемент
    roles.splice(2,1) //  вырежит 1 элемент 3й по порядку (т.е. "2,1" - 2 начало, 1 кол-во). изменяет масив!
    roles.slice(2) //  вернет все элементы начиная с 3. не изменяет массив. 
    roles.slice(0,2) //  вернет 2 элемент с 0 по 1 не включая 2
    roles.concat(usrAge) // объеденгить массивы
    roles.reverse() // переворачивает в обратном направлени. Модифицирует массив!

    // поиск\проверка элемента
    const elIndex = roles.indexOf('user') // 1  вернет первый найденый индекс нужного элемента 
    const elIndexx = roles.includes('user') // вернет true или false в зависимости есть ли элемент 
    console.log(elIndexx)

    // разбить (преобразовать) строку на массив
    const ссылка = 'auth/user/login';
    const результат = ссылка.split('/') // разбиваем и указываем разделитель
    console.log(результат) // получим  ['auth', 'user', 'login']

    // из массива в строку
    const строка = roles.join(', ');
    console.log(строка) // получим   admin, user, Новое имя, Добавить

    // Деструктуризация массива - берем структуру массива и разбиваем на отдельные элементы
    const userData = ['Антон', 18, "Полтава"];
    // БЫЛО -  много кода, 3 строки
    const userNames = userData[0];
    const userAge = userData[1];
    const userCity = userData[2];
    console.log(userNames + userAge + userCity)
    // СТАЛО - мало кода, 1 строка
    const [userNams, userAg, userCit] = userData;
    // const [userNams, _, userCit] = userData;  // если нужно только 2 переменные, то лишнюю можно закрасить символом _

    // Rest оператор
    // const [userNams, ...others] = userData;  // записываем 1 переменную, остальные элементы отправляются в ...others
    console.log(userNams + userAg + userCit)


    /************************/
    //   ЦИКЛЫ
    /************************/
    let массив = ['Задача1', 'Задача2', 'Задача3','Задача4']

    // стандартный обход массива. простая переборка  массива если НЕ НУЖЕН ИНДЕКС. обход идёт по значениям
    for (let element of массив) {
        console.log(element)
    }
    //  если нужен индес. обход идет по индексам
    for (let index in массив) {
        console.log(массив[index]) // вывести индекст
        console.log(index) // вывести значение
    }

    //  ЦИКЛ for используется для обычной итерации, т.е. увеличиваем на нужное значение (i++ или i+2...)
    //       начало;        условие;      шаг
    for( let i = 0; i < массив.length ; i++ ){
        console.log(массив[i])
        /*получим:  задача 1  задача 2 */

        /*  Доп условия Continue Breack
        if(массив[i] === 'Задача2') {
            continue; если нужно пропустить элемент то можно указать continue
            break; останавливает цикл
        }
        */
    }

    //  while - если нужно нестандартно проверить концец кикла то лучше использовать этот цикл
    let arrrr = [1,2,3,4]
    let abc = 0;
    while (arrrr[abc] <= 5 && abc < arrrr.length) { // т.е. если длина массива < 5 
        console.log(arrrr[abc]);
        abc++;
    }

    // do while - проверка сработает после проверки условия
    let j = 0;
    do {
        console.log(j)
        j++
    } while (j < 0)


    /************************/
    // Функции высшего порядка и функции первого класса
    /************************/

    // функция первого класса - это функция которую мы можешь использоваь как переменную, т.е. могут быть переданы в другие ф-ции и их можно вернуть из функций
    const w =  (b) => b++; // передаем аргумент b и потом увеличиваем на 1

    // функции высшего порядка - это те функции, которые либо принимают другие функции либо возвращают
    function g(w) { // функция g принимает! функцию w как аргумент
        return w; // возращаеn! функцию
    }

    // Callback - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия

    function add(a,b) { // простая функция
        return a + b
    }
    function culc(a,b, fn) { // функция высшего порядка, которая принимает в параметре fn функцию add
        return fn(a,b);
    }
    let res = culc(3,5, add) // результат


    
    // возврат одной функции из другой DEMO
    function power(pow) { // функция ничего не делает, просто возвращает другую функицю
        return function (num) { // эта функция возвращает число возведенное в степень
            return num**pow;
        }
    }
    //  короткая запись через стрелочную функцию   const power = pow => num => num**pow;
    const powerOfTwo = power(2); // результат выполнения функции power. т.е. создаем новую функцию с сохранением предыдущего контекста
    console.log(powerOfTwo(5))
    // console.log(power(2)(5))  // короткая запись. вызываем фунцию power(2) c аргументом 5

    /************************/
    // ИТЕРАЦИИ В МАССИВАХ
    /************************/

    // forEach - обходм массива . Есть проблемы с асинхронным кодом. Нельзя прикрат. цикл. Удобен для простого вывода\итерирования.
    const score = ["a","b","c","d"];                 // a 0
    score.forEach((el, i) => {      //получим        // b 1
        console.log(el, i)                           // c 2
    })                                               // d 3

    // map - позволяет взять исходный массив и как-то его преобразовать. Умножим каждый элемент массива на 60
    const cost = [5,6,7,8];
    const transInRub = cost.map((transaction, i) => {
        return transaction * 60
    });   // получим [300, 360, 420, 480]

    // filter  - Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
    //Пример: вернет все положительные числа из массива
    const operation = [100, -20, 7, -1, 50]
    const posotovOperat = operation.filter((op) => {
        return op > 0  
    }) // получим  [100, 7, 50]

    // reduce - сужаем массив до одного значения. Например, посчитаем финальную сумму (балланс)
    const bal = [100, -20, 7, -1, 50]
    const finalBalance = bal.reduce((acc, op) => {
        return acc += op; // получим 136 
    }, 0) // начальная величина т.е. 0

        // find - найти что-то в массиве
        // пример: найти перый элемент кот. больше 5
        const numbrs = [2,3,7,9]

        let ress;
        ress = numbrs.find(el => el >5); // получим 7
        // ress = numbrs.findIndex(el => el >5); // findIndex вернет индекс найденнго элемента.  получим 2
    
        //  some - проверяет массив на наличие элемента
        console.log(numbrs.some(el => el === 2))  // вернет true (2 есть в массиве)

        // flat - возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень
        const arr1 = [1, 2, [3, 4]];
        arr1.flat(); // (?) тут указываем значение глубины массива. по умолчанию 1
        // [1, 2, 3, 4]

        //  sort - сортировка  (мутируется существующий массив). ПО умолчанию работает как со строками
        // пример: отсортируем массив по алфавиту
        const arr3 = ['b','c', 'm', 'a'];
        arr3.sort(); // получим  ['a', 'b', 'c', 'm']

        // пример: отсортируем массив по порядку
        const arr4 = [5,-2, 1, 9];
        arr4.sort((a, b) => a - b); // получим  [-2, 1, 5, 9]


    /************************/
    // СТРОКИ
    /************************/

    const  userNm = 'Вася Пупкин';
    
    // ПОЛУЧАЕМ нужную букву из строки
    console.log(userNm[0])  //// получаем первую букву > В
    console.log(userNm.charAt(1)) // тоже самое только через метод charAt. получаем > В
    userNm = 'Вася Пупкин';[1] // самый простой вариант

    // Длина строки
    userNm.length // 11

    // Поиск по строки
    userNm.indexOf('П') // 5  (вернет первое вхождение найденой буквы)
    userNm.lastIndexOf('п') // 7  (вернет последнее вхождение найденой буквы)
    userNm.includes('п') // true
    userNm.slice('5') // вырежит 5 эдементов вернет > "Пупкин" 

    // Преобразование срок
    userNm.toLowerCase() // перевести все буквы в нижний регист 'вася пупкин' 
    userNm.toUpperCase() // перевести все буквы в верхний регист 'ВАСЯ ПУПКИН'
    userNm.replace('В', 'К') // меняем первую найденную букву В на К >  'Кася Пупкин'  (не подифиц. исход. объект)
    userNm.replaceAll('В', 'К') // заменит все найденные буквы В на К  (не везде поддерживается) Лучше делать так - userNm.replace(/В/, 'К')

    // Разбить строку на массив  
    userNm.split(' ')  // ['Вася', 'Пупкин']
    // Из массива в строку
    arr3.join(' ') // было ['a', 'b', 'c', 'm']   стало   'a b c m'

    // добавить символы в начало строки (указываем общее кол-во и нужный символ)
    userNm.padStart(20, '*') // '*********Вася Пупкин'  
    userNm.padEnd(12, '*') // 'Вася Пупкин****'
    userNm.repeat(2)// 'Вася ПупкинВася Пупкин'  повторить 2 раза


    /************************/
    // ОБЪЕКТЫ - коллекция свойств состоящая из пар ключ-значение.
    /************************/
    // пример объекта
    const user = {
        name: 'Вася', //свойство объекта
        surname: 'Пупкин',
        age: 24,
        1: 2,
        skills: [ // массив в обхеке
            'скорость',
            'выносливость',
        ],
        go: function() { // матод (любое св-во кот. яв-ся ссылкой на функци - назв. методом)
            console.log('123')
        }
    }

    // обращени к элементам
    console.log(user) // обращение ко всему объекту
    console.log(user.skills[0]) // "скорость"   - обращение к элементу массива

    console.log(user.skills) // не  доступно для расчетных свойств . Чаще всего используется
    console.log(user['skills']) // доступно для расчетных свойств. Например user['sur' + 'name'] где 'name' может быть переменная

    user.age = 30 // модифицируем объект (изменяем значение)
    user.city = 'Lviv' // добавляем новое значение

    // ПРАКТИКА!  Сортировка массива объектов по возрасту
    const users = [
        {name: 'Вася', age: 30},
        {name: 'Катя', age: 18},
        {name: 'Аня', age: 40},
        {name: 'Петя', age: 25},
    ]
    users.sort((a,b) => {
        return a.age - b.age
    })
    /* получаем:
        {name: 'Катя', age: 18}
        {name: 'Петя', age: 25}
        {name: 'Вася', age: 30}
        {name: 'Аня', age: 40}
    */


    // ПРАКТИКА!  преобразовать пользователей до вида {fullName: "Вася Пупкин", skillNum: 2}
    const users2 = [
        {
            name: 'Вася', 
            surname: 'Пупкин',
            age: 30,
            skills: ["Разработка", "DevOps"]
        },
        {
            name: 'Катя', 
            surname: 'Белова',
            age: 18,
            skills: ["дизайн"]
            } ,
    ]
    const result = users2.map(user => {
        return {
            fullName: `${user.name} ${user.surname}`,
            skillNum: user.skills.length
        };
    })
    /* получаем
        {fullName: 'Вася Пупкин', skillNum: 2}
        {fullName: 'Катя Белова', skillNum: 1}
    */




    // МЕТОДЫ объектов
    const user5 = {
        name: "Mike",
        surname: "Shinoda",
        getFullName: function(){ // матод. Можно писать без function 
            return this.name + " " + this.surname;
        }
    }
    console.log(user5.getFullName()) // вызов метода
    
    
    // итерирование по объекту
    const city = {
        msk: {
            left: 200,
            temp: 25
        },
        spb: {
            lt: 100,
            tp: 20
        }
    }
    for (const key in city) {
        console.log(key)
    }
    /* получим 
        msk
        pb
    */

    // деструктуризация и rest
    const user4 = {
        name: 'Вася', //свойство объекта
        surname: 'Пупкин',
        age: 24,
    }
    const{age, name} = user4; // деструктурируем  МОжно записать остальные данные в переменную с помощью rest пример:  {age, ...user7}
    /* получим
        name 'Вася'
        age 24
    */

    //    optional chaining - обход ошибки при вызове несуществующего свойства из объекта
    const citiess = {
        msk: {
            temp: {
                celcius: 25
            }
        },
        spb: {

        }
    } 
    console.log(citiess.msk?.temp?.celcius); // 25
    console.log(citiess.spb?.temp?.celcius); // undefined (нет ошибки, просто будет undefined при вызове)


    /************************/
    // Scope chain - область видимости
    /************************/
    // Глобальный scope - переменная доступна везде
    const b = 1; 

    // Scope функции - переменная доступна только внутри 
    function name() {
        const c = 1; функции
    }

    // Блочный scope -  переменная доступна только внутри 
    if (b<10){
        const d = 1;блока
        var d = 1; // var - исключение, будет виден как глобальная переменная
        
        function name() { // функция будет видна как глобальная, без строгого режима
            console.log('test') // 
        }
    }

    // Strict mode - строгий режим
    /*
        Невозможность объявления переменной без ключевого слова
        Blocked scope для функций (функции внутри блока не будут глобальными)
        Ограничение название переменных, которые могут добавиться в язык позднее (например const interface)
        Удаление переменных через delet 
        Дублируемый параметр (например function (a,a)- дублируются параметры)
    */


    /************************/
    // Поднятие - возможность использовать определённые типы переменных до того как они были объявлены 
    /************************/

    /*
     console.log(a)  = undefined (почему? потому что переменная вспылвет, но значения там не будет)
     var a = 1;

                  всплытие                начальное значение
     function       да                        сама функция
     var            да                        undefined
     let,cnst       нет                       unintialized
     arrow,func     зависит от переменной let var const (var - будет вести как var, let и конст - без всплытия)
    */

    /************************/
    //  This -  переменная, которая создается для каждого контекста исполнения. Ока указывает на владельца этой функции.addEventListener('type', listener, options)
    /************************/
    console.log(this) // window
    
    function name(params) {
        console.log(this)  // при строгом режиме = undefined, без строгого режима будет = window
    }

    const name11 = () => {
        console.log(this) // window = если функция нигде не вложена (берет из внешней обертки)
    }

    // 
    // Благодаря методу call() любой объект может использовать методы, принадлежащие другому объекту.
    // 
    var person = {
        fullName: function() {
            return this.firstName + " " + this.lastName;
        }
    }
    var person1 = {
        firstName:"John",
        lastName: "Doe",
    }
    var person2 = {
        firstName:"Mary",
        lastName: "Doe",
    }
    person.fullName.call(person1);   // вернет "John Doe" 

    // 
    // Bind - связывает наш this c функцией, котрую мы хотим вызвать. Метод возвращает новую функцию, внутри которой this будет равным переданному контексту.
    // 
    var obj = { num: 2 };

    function add(a, b){
        return this.num + a + b;
    }

    const func = add.bind(obj, 3, 5);
    func(); // Возвращает 10

    // 
    // Замыкания - приём когда создается функция внутри кототорой помещаются нужные данные и способы манипулирования с ними. Т.е. создаются изолированные области где можно выполнять один и тот же код но с разными переменными 
    // 
    function createStep() { // внутрь функции помещаем данные и другие функции (чаще 1 фн-ия с return), далее внешняя функция выполняется тем самым порождая замкнутую область и переменные и переменные будут изолированными
        let count = 0;
        return function () { // замыкание 
            count++;
            console.log(count)
        }
    }
    // в чем прелесть данной штуки? создаем разные переменные и в этих переменных будет разный результат
    let step1 = createStep();
    let step2 = createStep();
    step1() // 1
    step1() // 2
    step2() // 1  БУМ! ))  получаем свою область видимости и свою переменную :)))
    step1() // 3


    // 
    // DOM - document object modal - объектное представление исходного html документа . Благодаря нему мы можем манипулировать элементами на странице
    // 

    // Выбор и манипуляции с элементами
        // querySelector - озвращает первый элемент, который соответствует одному или более CSS селекторам. Если совпадения не будет, то он вернет null
        let ele = document.querySelector("#selector");

        // querySelectorAll() - возвращает все элементы (в виде NodeList), которые подходят под указанный CSS селектор

        let eles = document.querySelectorAll(".selector");
        let elesAttr = document.querySelectorAll(".selector")[0]; // вернет первый элемент из коллекции


        // Обработка нажатий 
        // 1 вариант - позволяет добавить несколько обработчиков для одинаковых событий. Т.е. таких функций можно делать сколько угодно на один объект 
        переменная.addEventListener('click', function () {
            console.log('click')
        });
        //  Используется если нужно выполнить одно действие по данному элементу. Т.е. если продублировать ниже такую де функцию, то сработает только плследнняя.
        переменная.onclick = function () {
            console.log('click')
        }

        // event this target 
        переменная.addEventListener('click', function (event) {
            console.log(this)               // вернет элемент на который навешен обработчик 
            console.log(event)              // вернет всю информацию по инвенту (куда нажали, какой кнопкой и тд)
            console.log(event.target)       // вернет элемент на который нажали (может вернуть внутренний элемент)
        })

        // Обработка событий клавиатуры
        elem.addEventListener("keydown", function (event) {
            console.log('keydown');
            if(event.keyCode == 81) {
               console.log("нажата q")
            }
        });

        // Установка атрибутов
        document.querySelector('.selector').getAttribute('class') // вернет все классы у селектора
        document.querySelector('.selector').setAttribute('class', 'qwe') // удалить все классы и установить .qwe

        // добавление html кода на лету
        const newElement = document.createElement('button');
        newElement.setAttribute('user-id', 1);
        newElement.classList.add('button');
        document.body.appendChild(newElement);
        // ПОЛУЧИМ - <button user-id="1" class="button"></button>

        //  Local storage
        localStorage.setItem('ключ','значение1'); // устанавливаем значение (всегда будет строка)
        localStorage.ключ = "значение2" // короткая запись
        localStorage.getItem('ключ'); // получаем значение ("значение1")
        localStorage.ключ // короткая запись получения значения
        localStorage.removeItem('ключ') //  удалить данные с ключом 
        localStorage.clear() // удалить все ключи и значения

        // JSON - текстовый формат обмена данными

        /* Есть 2 метода:
            JSON.stringify для преобразования объектов в JSON.
            JSON.parse для преобразования JSON обратно в объект.
        */
        const abt =  JSON.parse('{"a": 1, "b": 2}') // вернет объект > a: 1, b: 2
        const abt2 =  JSON.stringify(abt) // вернет строку >  {"a":1,"b":2}
</script>

        

</body>
</html>